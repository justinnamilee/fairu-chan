#!/usr/bin/perl

use strict;

# Cute script-chan for managing files!


use YAML;
use File::Spec;
use File::Copy;


sub badExit()
{
  print qq[\nErrors found while running, terminating.\n];

  exit 1;
}


###
# prototypes & globals

sub scanDir(_);

my $conf = undef;
my $run = undef;
my %dir = ();
my %map = ();


###
# import conf

unless (-f $ARGV[0] && ($conf = YAML::LoadFile($ARGV[0])))
{
  print "Unable to load / parse config file.\n";

  badExit();
}

if (defined($ARGV[1]) && lc($ARGV[1]) eq q[run])
{
  $run = 1;
}


###
# scan directories

foreach my $k (keys(%{$conf}))
{
  $dir{$conf->{$k}->{inFile}->{basePath}}++;
}

foreach my $d (sort(keys(%dir)))
{
  $dir{$d} = [scanDir($d)];
}


###
# filter for files

foreach my $k (keys(%{$conf}))
{
  my $g = $conf->{$k};
  my $r = qr/$g->{inFile}->{inRegex}/;

  foreach my $p (@{$dir{$g->{inFile}->{basePath}}})
  {
    my ($v, $d, $f) = File::Spec->splitpath($p);

    if ($f =~ $r)
    {
      # %+ is the special hash for named capture groups in Perl regex, we sort them and stuff them into sprintf
      my $out = File::Spec->join($g->{outFile}->{basePath}, sprintf($g->{outFile}->{outSprintf}, map { $+{$_} } sort keys(%+)));

      unless (-e $out)
      {
        $map{$p} = $out;
      }
    }
  }
}


###
# copy time!

foreach my $op (sort keys(%map))
{
  my $np = $map{$op};

  if (defined($conf->{fileMode}) && lc($conf->{fileMode}) eq q[move])
  {
    print qq[move($op, $np)\n];

    if ($run)
    {
      move($op, $np)
        or warn qq[Failed to move '$op' to '$np': $!\n];
    }
  }
  else
  {
    print qq[copy($op, $np)\n];
    
    if ($run)
    {
      copy($op, $np)
        or warn qq[Failed to copy '$op' to '$np': $!\n];
    }
  }
}



###
# subroutines

sub scanDir(_)
{
  my ($path, @f) = @_;

  if (opendir(my $dh, $path))
  {
    @f = map { File::Spec->join($path, $_) } grep { !/^\.\.?$/ } readdir($dh);
  }

  return @f;
}
