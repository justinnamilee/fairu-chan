#!/usr/bin/perl

use strict;

# Cute script-chan for managing files!


use YAML;
use File::Spec;
use File::Copy;


sub badExit()
{
  print qq[\nErrors found while running, terminating.\n];

  exit 1;
}


###
# prototypes & globals

sub scanDir(_);

my $data = undef;
my $meta = undef;
my $run = undef;
my $hook = undef;
my %dir = ();
my %map = ();


###
# import conf

if (-f $ARGV[0] && (my $conf = YAML::LoadFile($ARGV[0])))
{
  $data = $conf->{data};
  $meta = $conf->{meta};

  if (defined($meta->{discord}))
  {
    require WebService::Discord::Webhook;

    my $wh = WebService::Discord::Webhook->new(url => $meta->{discord}->{webhookUrl}, verify_SSL => 1);
    $wh->get();

    print qq[Configured with Discord support: $wh->{name} @ $wh->{channel_id}\n];

    $hook = sub
    {
      $wh->execute(sprintf($meta->{discord}->{template}, @_));
    }
  }
}
else
{
  print qq[Unable to load / parse config file.\n];

  badExit();
}

if (defined($ARGV[1]) && lc($ARGV[1]) eq q[run])
{
  $run = 1;
}


###
# scan directories

foreach my $k (keys(%{$data}))
{
  $dir{$data->{$k}->{inFile}->{basePath}}++;
}

foreach my $d (sort(keys(%dir)))
{
  $dir{$d} = [scanDir($d)];
}


###
# filter for files

foreach my $k (keys(%{$data}))
{
  my $g = $data->{$k};
  my $r = qr[$g->{inFile}->{inRegex}];

  foreach my $p (@{$dir{$g->{inFile}->{basePath}}})
  {
    my ($v, $d, $f) = File::Spec->splitpath($p);

    if ($f =~ $r)
    {
      # %+ is the special hash for named capture groups in Perl regex, we sort them and stuff them into sprintf
      my $out = File::Spec->join($g->{outFile}->{basePath}, sprintf($g->{outFile}->{outSprintf}, map { $+{$_} } sort keys(%+)));

      unless (-e $out)
      {
        $map{$p} = $out;
      }
    }
  }
}


###
# copy time!

foreach my $op (sort keys(%map))
{
  my $np = $map{$op};

  if (defined($data->{fileMode}) && lc($data->{fileMode}) eq q[move])
  {
    print qq[move($op, $np)\n];

    if ($run)
    {
      if (move($op, $np))
      {
        $hook->((File::Spec->splitpath($np))[2]) if defined($hook);
      }
      else
      {
        warn qq[Failed to move '$op' to '$np': $!\n];
      }
    }
  }
  else
  {
    print qq[copy($op, $np)\n];
    
    if ($run)
    {
      if (copy($op, $np))
      {
        $hook->((File::Spec->splitpath($np))[2]) if defined($hook);
      }
      else
      {
        warn qq[Failed to copy '$op' to '$np': $!\n];
      }
    }
  }
}



###
# subroutines

sub scanDir(_)
{
  my ($path, @f) = @_;

  if (opendir(my $dh, $path))
  {
    @f = map { File::Spec->join($path, $_) } grep { !/^\.\.?$/ } readdir($dh);
  }

  return @f;
}
